name: Refresh Agent Images (Tool Versions)
run-name: Refresh tool-version images (${{ github.ref_name }})

"on":
  push:
    tags:
      - "*"
  # The scheduler on GitHub is not reliable enough so a cron job at cron-job.org triggers this by workflow_dispatch
  #   schedule:
  #     - cron: "7,27,47 * * * *"
  workflow_dispatch: {}

concurrency:
  group: refresh-images
  cancel-in-progress: false

jobs:
  refresh:
    name: Refresh tool/base images
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}
      REF: ${{ github.ref }}
      ROOT_DIR: ${{ github.workspace }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.1

      - name: Install pipeline dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq skopeo

      - name: Dispatch builds when needed
        run: |
          set -euo pipefail
          source scripts/common.sh
          source scripts/refresh-images-lib.sh
          load_config_file

          MAX_PARALLEL="${REFRESH_CHECKS_PARALLELISM:-12}"
          FORCE_BUILD="false"
          if [[ "${GITHUB_EVENT_NAME}" == "push" ]]; then
            FORCE_BUILD="true"
          fi

          BASES_TMPDIR="$(download_bases_archive)"
          LOG_DIR="$(mktemp -d)"
          error_count=0
          pids=()
          declare -A pid_to_log pid_to_label

          log_name() {
            printf '%s' "$1" | tr -c '[:alnum:]_.-' '_'
          }

          dispatch_build() {
            local tool="$1"
            local base_alias="$2"
            local message="$3"

            echo "${message}"
            gh workflow run build.yml --ref "${REF}" -f tool="${tool}" -f base="${base_alias}"
          }

          needs_rebuild_status() {
            local tool="$1"
            local base_alias="$2"
            local tool_version="$3"
            local status output

            set +e
            output="$(needs_rebuild "${tool}" "${base_alias}" "${tool_version}" 2>&1)"
            status=$?
            set -e

            NEEDS_REBUILD_OUTPUT="${output}"
            printf '%s\n' "${status}"
          }

          report_pid_result() {
            local pid="$1"
            local status="$2"

            if [[ "${status}" -ne 0 ]]; then
              error_count=$((error_count + 1))
              echo "Check failed: ${pid_to_label[${pid}]}" >&2
              sed 's/^/  /' "${pid_to_log[${pid}]}" >&2
            else
              cat "${pid_to_log[${pid}]}"
            fi
          }

          wait_for_slot() {
            local finished_pid status

            if [[ "${#pids[@]}" -ge "${MAX_PARALLEL}" ]]; then
              if wait -n -p finished_pid; then
                status=0
              else
                status=$?
              fi
              report_pid_result "${finished_pid}" "${status}"
              mapfile -t pids < <(jobs -p)
            fi
          }

          run_check() {
            local tool="$1"
            local base_alias="$2"
            local tool_version="$3"

            if [[ "${FORCE_BUILD}" == "true" ]]; then
              dispatch_build "${tool}" "${base_alias}" \
                "Forcing build for ${tool} (${base_alias}) due to ${GITHUB_EVENT_NAME}"
              return 0
            fi

            local status
            status="$(needs_rebuild_status "${tool}" "${base_alias}" "${tool_version}")"
            case "${status}" in
              0)
                dispatch_build "${tool}" "${base_alias}" \
                  "Dispatching ${tool} (${base_alias}) for ${REF}"
                return 0
                ;;
              1)
                echo "Up-to-date ${tool} (${base_alias})"
                return 0
                ;;
              *)
                if [[ -n "${NEEDS_REBUILD_OUTPUT}" ]]; then
                  echo "${NEEDS_REBUILD_OUTPUT}" >&2
                fi
                echo "Failed to determine rebuild for ${tool} (${base_alias})" >&2
                return 1
                ;;
            esac
          }

          for dir in tools/*; do
            [ -d "${dir}" ] || continue
            TOOL="$(basename "${dir}")"
            TOOL_VERSION="$(tools/${TOOL}/version.sh)"
            if [[ -z "${TOOL_VERSION}" ]]; then
              echo "Tool version is empty for ${TOOL}" >&2
              exit 1
            fi
            BASE_ALIASES="$(get_bases "${TOOL}" "${BASES_TMPDIR}/bases")"

            for BASE_ALIAS in ${BASE_ALIASES}; do
              log_file="${LOG_DIR}/$(log_name "${TOOL}_${BASE_ALIAS}").log"
              run_check "${TOOL}" "${BASE_ALIAS}" "${TOOL_VERSION}" >"${log_file}" 2>&1 &
              pid="$!"
              pids+=("${pid}")
              pid_to_log["${pid}"]="${log_file}"
              pid_to_label["${pid}"]="${TOOL} (${BASE_ALIAS})"

              wait_for_slot
            done
          done

          for pid in "${pids[@]}"; do
            if wait "${pid}"; then
              report_pid_result "${pid}" 0
            else
              report_pid_result "${pid}" $?
            fi
          done

          if [[ "${error_count}" -gt 0 ]]; then
            echo "Refresh checks reported ${error_count} error(s)." >&2
            exit 1
          fi
